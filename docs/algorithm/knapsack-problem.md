# 背包问题

背包问题是经典的**动态规划**问题。

## 01 背包问题

01 背包问题（01 knapsack problem）是最基础的背包问题。

给定`n`件物品和一背包。物品`i`的重量为`w[i]`，其价值为`v[i]`，背包容量为`c`。

求应如何选择装入背包中的物品，使得装入背包中物品的总价值最大？

### 定义最优子结构

设`dp[i][j]`表示将前`i`件物品装入容量为`j`的背包可以获得的最大价值。其中，`0 <= i <= n`，`0 <= j <= W`。

### 确定转移方程

对于第`i`件物品来说，存在两种情况。即选择不装入或装入背包。

1. 不装入：`dp[i][j] = dp[i-1][j]`
2. 装入：`dp[i][j] = dp[i-1][j-w[i]] + v[i]`

所以转移方程为：`dp[i][j]=max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])`，其中`j>=w[i]`。

### 确定边界条件

-   当背包容量为`0`时，`dp[i][0]=0`
-   背包装入`0`件物品，则`dp[0][j]=0`

### 自底向上进行计算求解

```java
class Solution {
    public int max(int c, int[] w, int[] v) {
        int n = w.length;
        int[][] dp = new int[n + 1][c + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= c; j++) {
                dp[i][j] = j >= w[i - 1] ? Math.max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]) : dp[i - 1][j];
            }
        }

        // 反推都有哪件物品被装入了背包
        // int i = n;
        // int j = c;
        // while (i > 0 && j > 0) {
        //     if (dp[i][j] != dp[i - 1][j]) {
        //         System.out.println("第" + i + "件物品被装入背包");
        //         j = j - w[i - 1];
        //     }
        //     i = i - 1;
        // }
        return dp[n][c];
    }
}
```

## 完全背包问题

给定`n`种物品和一背包，每种商品有无限多个。第`i`种物品的重量为`w[i]`，其价值为`v[i]`，背包容量为`c`。

求应如何选择装入背包中的物品，使得装入背包中物品的总价值最大？

### 定义最优子结构

设`dp[i][j]`表示将前`i`种物品装入容量为`j`的背包可以获得的最大价值。其中，`0 <= i <= n`，`0 <= j <= W`。

### 确定转移方程

**完全背包问题**与**01 背包问题**相比，差别在于每种放入背包的物品都可以有多个。

对于第`i`种物品，如果不放入背包中，那么和**01 背包问题**一样：`dp[i][j]=dp[i-1][j]`。

但如果放入背包中，那么`dp[i][j]=dp[i][j-w[i]]+v[i]`。

因为装入第`i`种商品以后还可以再继续装入该种商品，所以`dp[i][j]`转移到`dp[i][j-w[i]]+v[i]`而不是**01 背包问题**的`dp[i-1][j-w[i]]+v[i]`。

所以，转移方程为：`dp[i][j]=max(dp[i-1][j], dp[i][j-w[i]]+v[i])`。其中，`j>=w[i]`。

### 确定边界条件

与**01 背包问题**的边界条件相同：

-   当背包容量为`0`时，`dp[i][0]=0`
-   背包装入`0`件物品，则`dp[0][j]=0`

### 自底向上进行计算求解

```java
class Solution {
    public int max(int c, int[] w, int[] v) {
        int n = w.length;
        int[][] dp = new int[n + 1][c + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= c; j++) {
                dp[i][j] = j >= w[i - 1] ? Math.max(dp[i - 1][j], dp[i][j - w[i - 1]] + v[i - 1]) : dp[i - 1][j];
            }
        }

        // 反推都有哪件物品被装入了背包
        // int i = n;
        // int j = c;
        // while (i > 0 && j > 0) {
        //     if (dp[i][j] != dp[i - 1][j]) {
        //         System.out.println("第" + i + "件物品被装入背包");
        //         j = j - w[i - 1];
        //     }
        //     i = i - 1;
        // }
        return dp[n][c];
    }
}
```
